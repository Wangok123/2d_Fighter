# 2D Fighter 客户端架构

## 架构概览

客户端采用分层架构设计，遵循LAT框架的设计理念，将代码分为Core（核心层）和UnityCore（Unity层）两大部分。

```
┌─────────────────────────────────────────────┐
│         Application Layer (应用层)           │
│     GameLauncher, UI, GamePlay Logic       │
└─────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────┐
│        UnityCore Layer (Unity框架层)         │
│  Network, Combat, Audio, ResourceSystem    │
│  SceneManagement, Input, UI, Entities      │
└─────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────┐
│          Core Layer (核心框架层)             │
│   ObjectPool, EventSystem, StateMachine    │
│   BinaryTools, ReferencePool, Utils        │
└─────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────┐
│      Third Party & Unity Engine (底层)      │
│  Unity Engine, DOTween, UniTask, Photon    │
└─────────────────────────────────────────────┘
```

## Core层（核心框架层）

Core层是平台无关的核心框架，不依赖Unity，可以独立运行。

### 1. ObjectPool（对象池）

**路径**：`Client/Assets/Scripts/Core/ObjectPool/`

**核心类**：
- `IObjectPoolManager`：对象池管理器接口
- `ObjectPoolManager`：对象池管理器实现
- `ObjectPoolBase`：对象池基类
- `ObjectBase`：池对象基类
- `ObjectInfo`：对象信息

**功能**：
- 对象的创建和销毁管理
- 自动回收和重用
- 内存优化
- 性能提升

**使用场景**：
- 子弹、特效等频繁创建销毁的对象
- UI元素的复用
- 临时数据结构

**代码示例**：
```csharp
// 获取对象
var obj = ObjectPoolManager.Instance.Spawn<BulletObject>();

// 回收对象
ObjectPoolManager.Instance.Unspawn(obj);
```

### 2. EventSystem（事件系统）

**路径**：`Client/Assets/Scripts/Core/EventSystem/`

**功能**：
- 解耦模块间通信
- 事件订阅和发布
- 类型安全的事件参数

**特点**：
- 基于委托的事件分发
- 支持泛型事件参数
- 自动管理生命周期

**使用场景**：
- 模块间通信
- UI更新通知
- 游戏状态变化通知

### 3. StateMachine（状态机）

**路径**：`Client/Assets/Scripts/Core/StateMachine/`

**功能**：
- 状态管理
- 状态转换
- 状态生命周期管理

**应用**：
- 角色AI状态
- 游戏流程状态
- UI界面状态

### 4. BinaryTools（二进制工具）

**路径**：`Client/Assets/Scripts/Core/BinaryTools/`

**核心类**：
- `BinaryTool.BinaryWriter`：二进制写入器
- `BinaryTool.BinaryReader`：二进制读取器
- `BufferReader`：缓冲区读取器

**功能**：
- 高效的二进制序列化
- 网络数据包读写
- 存档数据处理

### 5. ReferencePool（引用池）

**路径**：`Client/Assets/Scripts/Core/ReferencePool/`

**功能**：
- 引用类型对象池
- 减少GC压力
- 提升性能

### 6. CustomDataStruct（自定义数据结构）

**路径**：`Client/Assets/Scripts/Core/CustomDataStruct/`

**包含**：
- 高性能数据结构
- 游戏特定数据结构

### 7. Utils（工具类）

**路径**：`Client/Assets/Scripts/Core/Utils/`

**包含**：
- `ListPool`：列表对象池
- `WeightedRandom`：权重随机
- `ArraySortHelper`：数组排序助手
- `MathCommon`：数学工具
- `ArrayUtil`：数组工具
- `ObjectPool`：通用对象池

## UnityCore层（Unity框架层）

UnityCore层是基于Unity引擎的游戏框架层，提供Unity相关的功能模块。

### 1. Network（网络模块）

**路径**：`Client/Assets/Scripts/UnityCore/Network/`

**功能**：
- 与服务器通信
- 协议收发
- 连接管理
- 断线重连

**核心组件**：
- 网络管理器
- 消息分发器
- 协议处理器

**支持协议**：
- KCP/UDP
- Protobuf序列化

### 2. Combat（战斗系统）

**路径**：`Client/Assets/Scripts/UnityCore/Combat/`

**功能**：
- 战斗逻辑
- 技能系统
- 伤害计算
- 碰撞检测

**特点**：
- 客户端预测
- 服务器验证
- 帧同步支持

### 3. Entities（实体系统）

**路径**：`Client/Assets/Scripts/UnityCore/Entities/`

**功能**：
- 游戏实体管理
- 角色、敌人、道具等
- 实体生命周期管理

**设计模式**：
- 组件模式
- 实体-组件分离

### 4. UI（用户界面）

**路径**：`Client/Assets/Scripts/UnityCore/UI/`

**功能**：
- UI界面管理
- 界面栈管理
- UI事件处理
- UI动画

**特点**：
- UGUI为基础
- MVVM模式（部分）
- 界面预加载
- 自动回收

### 5. ResourceSystem（资源系统）

**路径**：`Client/Assets/Scripts/UnityCore/ResourceSystem/`

**功能**：
- 资源加载
- 资源卸载
- 依赖管理
- 内存管理

**集成**：
- YooAsset
- Addressables

**特性**：
- 异步加载
- 引用计数
- 自动卸载

### 6. SceneManagement（场景管理）

**路径**：`Client/Assets/Scripts/UnityCore/SceneManagement/`

**功能**：
- 场景加载
- 场景卸载
- 场景切换
- 过渡动画

**核心类**：
- `GameSceneSO`：场景配置ScriptableObject

**流程**：
1. 加载基础场景（BaseScene）
2. 等待组件初始化
3. 加载初始场景列表
4. 切换到主界面

### 7. Input（输入系统）

**路径**：`Client/Assets/Scripts/UnityCore/Input/`

**功能**：
- 输入采集
- 输入映射
- 多设备支持

**集成**：
- Unity Input System
- 自定义输入管理

### 8. Audio（音频系统）

**路径**：`Client/Assets/Scripts/UnityCore/Audio/`

**功能**：
- 音效播放
- 背景音乐
- 音量控制
- 音频池管理

### 9. Simulation（模拟系统）

**路径**：`Client/Assets/Scripts/UnityCore/Simulation/`

**功能**：
- 战斗回放
- 物理模拟
- 确定性计算

**应用**：
- 录像系统
- 战斗验证
- AI训练

### 10. GameModule（游戏模块）

**路径**：`Client/Assets/Scripts/UnityCore/GameModule/`

**功能**：
- 游戏业务逻辑模块
- 玩家系统
- 背包系统
- 商城系统等

### 11. Base（基础组件）

**路径**：`Client/Assets/Scripts/UnityCore/Base/`

**核心类**：
- `LatComponent`：LAT组件基类

**功能**：
- 组件生命周期管理
- 初始化标记（IsInit）

### 12. EventDefine（事件定义）

**路径**：`Client/Assets/Scripts/UnityCore/EventDefine/`

**功能**：
- 游戏事件定义
- 事件参数类型

**示例**：
- `SceneEventDefine`：场景相关事件

### 13. Configs（配置系统）

**路径**：`Client/Assets/Scripts/UnityCore/Configs/`

**功能**：
- 配置数据加载
- 配置表管理
- 热更新配置

### 14. SaveSystem（存档系统）

**路径**：`Client/Assets/Scripts/UnityCore/SaveSystem/`

**功能**：
- 本地存档
- 云存档
- 数据加密

### 15. Extensions（扩展方法）

**路径**：`Client/Assets/Scripts/UnityCore/Extensions/`

**功能**：
- Unity组件扩展
- C#类型扩展
- 工具方法扩展

## Gen层（生成代码）

**路径**：`Client/Assets/Scripts/Gen/`

### 子目录：

#### 1. demo
- 示例配置生成代码

#### 2. latEnum
- 枚举定义

#### 3. latcfg
- 配置表代码

**生成工具**：
- Luban配置表生成
- Protobuf协议生成

## 启动流程

### GameLauncher启动流程

```
1. GameLauncher.Start()
   ↓
2. 加载BaseScene（基础场景）
   ↓
3. 等待LatComponent初始化完成
   ↓
4. 加载initialSceneList（初始场景列表）
   ↓
5. 发送ChangeToHomeScene事件
   ↓
6. 卸载启动场景
```

**关键代码**：`Client/Assets/Scripts/GameLauncher.cs`

## 模块通信

### 1. 事件通信
- 通过EventSystem发送和接收事件
- 松耦合，易于维护

### 2. 接口依赖
- 通过接口定义模块间的依赖
- 依赖倒置原则

### 3. 单例管理器
- 各模块通过Manager单例访问
- 全局访问点

## 资源管理流程

```
1. 请求资源加载
   ↓
2. ResourceSystem查找资源
   ↓
3. YooAsset/Addressables加载
   ↓
4. 引用计数+1
   ↓
5. 返回资源句柄
   ↓
6. 使用完毕调用卸载
   ↓
7. 引用计数-1
   ↓
8. 计数为0时真正卸载
```

## 性能优化策略

### 1. 对象池
- 频繁创建的对象使用对象池
- 减少GC压力

### 2. 异步加载
- 资源异步加载
- 避免卡顿

### 3. LOD系统
- 远近不同精度的模型
- 减少渲染负担

### 4. 批处理
- 合批渲染
- 减少DrawCall

### 5. 资源卸载
- 及时卸载不用的资源
- 控制内存占用

## 开发规范

### 1. 命名规范
- 类名：PascalCase
- 方法名：PascalCase
- 变量名：camelCase
- 私有字段：_camelCase
- 常量：UPPER_SNAKE_CASE

### 2. 代码组织
- 一个文件一个类
- 相关类放在同一目录
- 接口和实现分离

### 3. 注释规范
- 公共API必须有XML注释
- 复杂逻辑必须有说明
- TODO标记待完成事项

### 4. 异步处理
- 优先使用UniTask
- 避免使用协程（除非必要）
- 正确处理取消令牌

## 调试和测试

### 1. 日志系统
- 使用统一的日志接口
- 分级别记录日志
- 支持日志过滤

### 2. 调试工具
- Inspector调试
- Gizmos可视化
- 运行时调试窗口

### 3. 单元测试
- Unity Test Framework
- 测试核心逻辑
- 自动化测试

## 常见问题

### Q1: 如何添加新的游戏模块？
A: 
1. 在UnityCore下创建模块目录
2. 实现Manager类（单例）
3. 在GameLauncher或BaseScene中初始化
4. 通过EventSystem与其他模块通信

### Q2: 如何优化加载速度？
A:
1. 使用异步加载
2. 预加载常用资源
3. 使用资源分包
4. 优化资源依赖关系

### Q3: 如何处理内存占用过高？
A:
1. 检查资源是否正确卸载
2. 使用对象池减少内存分配
3. 使用Profiler分析内存占用
4. 及时清理不用的缓存

## 相关文档

- [项目总览](01-项目总览.md)
- [技术栈详解](02-技术栈.md)
- [服务端架构](04-服务端架构.md)
- [LAT框架说明](LAT框架.md)
- [Core模块详解](Core/概述.md)
