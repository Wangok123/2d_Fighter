# 从现有Animator迁移指南 / Migration Guide from Existing Animator

## 概述 / Overview

本指南帮助您将现有的Unity Animator Controller迁移到新的AnimationStateManager系统。

This guide helps you migrate your existing Unity Animator Controller to the new AnimationStateManager system.

## 迁移步骤 / Migration Steps

### 步骤1：保留现有资源 / Step 1: Keep Existing Assets

**重要：不要删除Animator Controller！**
**Important: Do NOT delete the Animator Controller!**

新系统仍然使用Animator Controller，只是不再需要手动创建Transition。

The new system still uses the Animator Controller, it just doesn't require manual Transitions anymore.

### 步骤2：简化Animator Controller / Step 2: Simplify Animator Controller

1. 打开Warrior.controller（在Unity编辑器中）
2. **可选：** 删除所有State之间的Transition连线（但保留States本身）
3. 保存Animator Controller

注意：即使保留Transitions也没关系，新系统会直接通过代码控制动画切换。

Note: It's fine to keep Transitions if you want, the new system will control animation switching directly through code.

### 步骤3：添加WarriorAnimationManager组件 / Step 3: Add WarriorAnimationManager Component

为Warrior角色GameObject添加WarriorAnimationManager组件：

1. 在Unity中选择Warrior角色GameObject
2. 点击 Add Component
3. 搜索 "WarriorAnimationManager"
4. 添加组件

组件会自动找到Animator组件并初始化所有动画状态。

The component will automatically find the Animator component and initialize all animation states.

### 步骤4：更新现有代码 / Step 4: Update Existing Code

#### 旧代码示例 / Old Code Example

```csharp
// 旧方式 - 使用Animator参数和Trigger
// Old way - Using Animator parameters and triggers

public class OldPlayerController : MonoBehaviour
{
    private Animator animator;

    void Start()
    {
        animator = GetComponent<Animator>();
    }

    void Update()
    {
        // 设置参数来触发动画
        animator.SetBool("isRunning", isRunning);
        animator.SetTrigger("Jump");
        animator.SetFloat("Speed", speed);
    }
}
```

#### 新代码示例 / New Code Example

```csharp
// 新方式 - 使用WarriorAnimationManager
// New way - Using WarriorAnimationManager

using Quantum.QuantumView;

public class NewPlayerController : MonoBehaviour
{
    private WarriorAnimationManager animManager;

    void Start()
    {
        animManager = GetComponent<WarriorAnimationManager>();
    }

    void Update()
    {
        // 直接播放动画
        if (isRunning)
            animManager.PlayRun();
        else
            animManager.PlayIdle();
        
        if (Input.GetKeyDown(KeyCode.Space))
            animManager.PlayJump();
    }
}
```

### 步骤5：测试动画播放 / Step 5: Test Animation Playback

1. 运行游戏
2. 检查Console是否有初始化日志：
   ```
   Warrior Animation Manager initialized with all states
   ```
3. 测试所有动画是否正常播放
4. 检查动画过渡是否流畅

## 常见迁移场景 / Common Migration Scenarios

### 场景1：从Animator Parameters迁移

#### 之前 / Before
```csharp
animator.SetBool("isGrounded", true);
animator.SetFloat("verticalSpeed", velocity.y);
```

#### 之后 / After
```csharp
if (isGrounded)
    animManager.PlayIdle();
else if (velocity.y > 0)
    animManager.PlayJump();
else
    animManager.PlayFall();
```

### 场景2：从Trigger迁移

#### 之前 / Before
```csharp
if (Input.GetButtonDown("Attack"))
{
    animator.SetTrigger("Attack");
}
```

#### 之后 / After
```csharp
if (Input.GetButtonDown("Attack"))
{
    animManager.PlayAttack();
}
```

### 场景3：检查动画状态

#### 之前 / Before
```csharp
AnimatorStateInfo stateInfo = animator.GetCurrentAnimatorStateInfo(0);
if (stateInfo.IsName("Attack"))
{
    // 正在攻击
}
```

#### 之后 / After
```csharp
if (animManager.IsPlaying(WarriorAnimationManager.AnimationStates.Attack))
{
    // 正在攻击
}
```

### 场景4：等待动画完成

#### 之前 / Before
```csharp
AnimatorStateInfo stateInfo = animator.GetCurrentAnimatorStateInfo(0);
if (stateInfo.IsName("Attack") && stateInfo.normalizedTime >= 1.0f)
{
    // 攻击完成
    animator.SetTrigger("Idle");
}
```

#### 之后 / After
```csharp
if (animManager.IsPlaying(WarriorAnimationManager.AnimationStates.Attack) && 
    animManager.IsCurrentAnimationFinished())
{
    // 攻击完成
    animManager.PlayIdle();
}
```

## 混合使用 / Hybrid Approach

如果您想逐步迁移，可以同时使用两种方式：

If you want to migrate gradually, you can use both approaches simultaneously:

```csharp
public class HybridController : MonoBehaviour
{
    private Animator animator;
    private WarriorAnimationManager animManager;

    void Start()
    {
        animator = GetComponent<Animator>();
        animManager = GetComponent<WarriorAnimationManager>();
    }

    void Update()
    {
        // 新代码 - 使用AnimationManager
        if (Input.GetKeyDown(KeyCode.Space))
            animManager.PlayJump();
        
        // 旧代码 - 仍然可以使用Animator parameters
        animator.SetFloat("Speed", currentSpeed);
    }
}
```

## 性能对比 / Performance Comparison

### 旧方式性能 / Old Approach Performance
- 每帧检查多个Bool/Float参数
- Transition条件评估开销
- 多个Transition的CPU开销

### 新方式性能 / New Approach Performance
- 直接调用CrossFade/Play，无条件评估
- 使用预计算的Hash值
- 只在状态改变时调用，避免每帧开销

**结论：新方式性能更好**
**Conclusion: New approach has better performance**

## 故障排除 / Troubleshooting

### 问题：动画不播放

**检查清单：**
1. WarriorAnimationManager组件是否已添加？
2. Animator组件是否存在于同一GameObject？
3. Animator Controller是否正确设置？
4. 动画状态名称是否与Controller中的名称完全一致？
5. Console中是否有错误日志？

### 问题：动画切换不流畅

**解决方案：**
1. 检查crossfadeDuration设置（在WarriorAnimationManager.cs中）
2. 确保动画本身支持blend
3. 避免在同一帧内多次调用PlayAnimation()

### 问题：某些动画找不到

**解决方案：**
1. 检查WarriorAnimationManager.cs中的AnimationStates常量
2. 确保动画状态名称与Animator Controller中完全一致
3. 如果是自定义动画，使用RegisterState()手动注册

## 回滚方案 / Rollback Plan

如果需要回滚到旧系统：

1. 移除WarriorAnimationManager组件
2. 恢复原来的代码（使用Animator.SetTrigger等）
3. 在Animator Controller中重新创建Transitions
4. 新系统的代码不会影响Animator Controller的功能

## 最佳实践建议 / Best Practice Recommendations

1. **逐步迁移** - 先迁移简单的动画，再迁移复杂的
2. **保留旧代码** - 在迁移完成前，保留旧代码作为参考
3. **充分测试** - 测试所有动画和状态切换
4. **使用常量** - 使用AnimationStates常量避免拼写错误
5. **添加注释** - 在关键位置添加注释说明动画逻辑

## 支持 / Support

如果遇到问题，请参考：
- 完整文档：`Md/Core/动画状态管理系统.md`
- 示例代码：`Client/Assets/Scripts/Examples/AnimationSystemExample.cs`
- README：`Client/Assets/Scripts/Core/AnimationSystem/README.md`
