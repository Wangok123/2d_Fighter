# 格斗游戏动画系统 - 取消机制与投技系统
# Fighting Game Animation System - Cancel Mechanism & Throw System

## 概述 / Overview

本文档介绍为2D格斗游戏设计的高级动画系统，包含：
This document introduces an advanced animation system designed for 2D fighting games, including:

1. **动画优先级系统** / Animation Priority System
2. **取消机制** / Cancel Mechanism  
3. **投技/抓取系统** / Throw/Grapple System
4. **智能受击反应** / Smart Hit Reactions

这些系统解决了格斗游戏中复杂的动画切换问题，特别是：
These systems solve complex animation transition issues in fighting games, especially:

- 如何控制哪些动画可以打断其他动画
- 如何实现连招系统（通过取消窗口）
- 如何实现投技攻击（像街霸的桑吉尔夫）
- 如何区分地面受击和空中受击

## 核心概念 / Core Concepts

### 1. 动画优先级 (Animation Priority)

每个动画都有一个优先级，决定它能否打断其他动画：

```
Idle (0) < Movement (10) < Jump (20) < Attack (30) < Skill (40) 
  < Throw (50) < Hit (60) < Knockdown (70) < Death (100)
```

**规则 / Rules:**
- 高优先级动画可以打断低优先级动画
- Higher priority animations can interrupt lower priority animations
- 相同优先级需要检查取消策略
- Same priority requires checking cancel policy

### 2. 取消策略 (Cancel Policy)

定义动画何时可以被取消：

| 策略 | 说明 | 使用场景 |
|------|------|----------|
| `NonCancellable` | 不可取消，必须播完 | 死亡、投技执行 |
| `AlwaysCancellable` | 任何时候都可取消 | Idle、Run |
| `CancellableInWindow` | 仅在特定时间窗口可取消 | 攻击连招 |
| `CancellableOnEnd` | 接近结束时可取消 | 技能恢复 |
| `OnlyByHigherPriority` | 仅可被更高优先级打断 | 受击、投技抓取 |

### 3. 取消窗口 (Cancel Window)

取消窗口定义了动画中可以被取消的精确时间范围：

```csharp
// 示例：攻击动画在40%-70%可以取消到另一个攻击
new CancelWindow(0.4f, 0.7f, new[] { "Attack", "DashAttack", "Throw_Start" })

// 在80%以后可以取消到任意动作
new CancelWindow(0.8f, 1.0f)  // null = 允许任何目标
```

这个机制允许实现精确的连招系统，类似真实格斗游戏。

## 使用指南 / Usage Guide

### 基础使用 / Basic Usage

#### 1. 注册带优先级的动画状态

```csharp
public class MyCharacterAnimationManager : CharacterAnimationManager
{
    protected override void RegisterAnimationStates()
    {
        // 基础移动 - 低优先级，随时可取消
        RegisterState("Idle", 
            priority: AnimationPriority.Idle,
            cancelPolicy: AnimationCancelPolicy.AlwaysCancellable,
            isDefault: true);

        RegisterState("Run", 
            priority: AnimationPriority.Movement,
            cancelPolicy: AnimationCancelPolicy.AlwaysCancellable);

        // 攻击 - 中等优先级，有取消窗口支持连招
        RegisterState("Attack", 
            priority: AnimationPriority.Attack,
            cancelPolicy: AnimationCancelPolicy.CancellableInWindow,
            cancelWindows: new[] {
                // 40%-70%可以取消到其他攻击
                new CancelWindow(0.4f, 0.7f, new[] { "Attack", "Skill" }),
                // 80%以后可以取消到任何动作
                new CancelWindow(0.8f, 1.0f)
            });

        // 受击 - 高优先级，只能被更高优先级打断
        RegisterState("Hurt", 
            priority: AnimationPriority.Hit,
            cancelPolicy: AnimationCancelPolicy.OnlyByHigherPriority);

        // 死亡 - 最高优先级，不可取消
        RegisterState("Death", 
            priority: AnimationPriority.Death,
            cancelPolicy: AnimationCancelPolicy.NonCancellable);
    }
}
```

#### 2. 播放动画（自动检查取消规则）

```csharp
// 普通播放 - 会检查取消规则
_animManager.PlayAnimation("Attack");

// 检查是否可以播放（不实际播放）
if (_animManager.CanPlayAnimation("Attack"))
{
    _animManager.PlayAnimation("Attack");
    Debug.Log("Attack started!");
}
else
{
    Debug.Log("Cannot attack now - blocked by cancel rules");
}

// 强制播放 - 忽略取消规则
_animManager.PlayAnimation("Idle", forceReplay: false, ignoreCancelRules: true);
```

#### 3. 查询优先级信息

```csharp
// 获取当前动画优先级
AnimationPriority currentPriority = _animManager.GetCurrentPriority();

// 获取指定动画的优先级
AnimationPriority attackPriority = _animManager.GetPriority("Attack");

// 检查当前动画进度
float progress = _animManager.GetAnimationNormalizedTime();
```

### 投技系统使用 / Throw System Usage

#### 1. 添加投技组件

```csharp
// 在角色GameObject上添加ThrowAttackComponent
[RequireComponent(typeof(WarriorAnimationManager))]
[RequireComponent(typeof(ThrowAttackComponent))]
public class FighterController : MonoBehaviour
{
    private ThrowAttackComponent _throwComponent;

    void Awake()
    {
        _throwComponent = GetComponent<ThrowAttackComponent>();
        
        // 订阅投技事件
        _throwComponent.OnThrowStarted += OnThrowStarted;
        _throwComponent.OnThrowExecuted += OnThrowExecuted;
        _throwComponent.OnThrowCompleted += OnThrowCompleted;
    }

    void Update()
    {
        // 按T键尝试投技
        if (Input.GetKeyDown(KeyCode.T))
        {
            bool success = _throwComponent.TryThrow();
            if (success)
            {
                Debug.Log("Throw initiated!");
            }
        }
    }

    private void OnThrowStarted(GameObject target)
    {
        Debug.Log($"Grabbed: {target.name}");
    }

    private void OnThrowExecuted(GameObject target)
    {
        Debug.Log($"Throw executed on: {target.name}");
    }

    private void OnThrowCompleted()
    {
        Debug.Log("Throw completed");
    }
}
```

#### 2. 配置投技参数（在Inspector中）

- **Grab Range**: 抓取范围（默认1.5米）
- **Grab Angle**: 抓取角度（默认45度）
- **Throw Damage**: 投技伤害
- **Knockback Force**: 击退力度
- **Throw Break Window**: 破解窗口时间

#### 3. 实现可被抓取的角色

```csharp
public class ThrowableCharacter : MonoBehaviour, IThrowable
{
    private bool _canBeGrabbed = true;
    private bool _isBeingGrabbed = false;

    public bool CanBeGrabbed()
    {
        // 检查是否可以被抓取（例如：不在无敌状态）
        return _canBeGrabbed && !_isBeingGrabbed;
    }

    public void OnGrabbed(GameObject attacker)
    {
        Debug.Log($"I was grabbed by {attacker.name}!");
        _isBeingGrabbed = true;
        
        // 播放被抓取动画
        GetComponent<CharacterAnimationManager>()?.PlayAnimation("Grabbed");
    }

    public void OnThrowBroken()
    {
        Debug.Log("I broke the throw!");
        _isBeingGrabbed = false;
    }

    public void OnReleased()
    {
        Debug.Log("Released from throw");
        _isBeingGrabbed = false;
    }
}
```

#### 4. 投技破解机制

被抓取的角色可以在破解窗口内尝试破解投技：

```csharp
public class DefenderController : MonoBehaviour
{
    private ThrowAttackComponent _enemyThrowComponent;

    void Update()
    {
        // 按特定按键破解投技
        if (Input.GetKeyDown(KeyCode.E))
        {
            if (_enemyThrowComponent != null)
            {
                bool success = _enemyThrowComponent.TryBreakThrow();
                if (success)
                {
                    Debug.Log("Successfully broke the throw!");
                }
            }
        }
    }
}
```

### 智能受击系统 / Smart Hit System

系统支持根据角色状态自动选择合适的受击动画：

```csharp
public class FighterController : MonoBehaviour
{
    private WarriorAnimationManager _animManager;
    private bool _isGrounded = true;

    public void TakeDamage(float damage)
    {
        // 智能受击 - 自动判断地面/空中
        _animManager.PlaySmartHurt(_isGrounded);
        
        // 或者手动指定
        if (_isGrounded)
        {
            _animManager.PlayHurtGround();
        }
        else
        {
            _animManager.PlayHurtAir();
        }
    }
}
```

## 实战示例 / Practical Examples

### 示例1: 实现三段攻击连招

```csharp
public class ComboSystem : MonoBehaviour
{
    private WarriorAnimationManager _animManager;
    private int _comboCount = 0;

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.F))
        {
            // 检查是否可以继续连招
            if (_animManager.CanPlayAnimation("Attack"))
            {
                _animManager.PlayAttack();
                _comboCount++;
                
                if (_comboCount >= 3)
                {
                    // 第三段可以取消到必杀技
                    _comboCount = 0;
                }
            }
        }
    }
}
```

### 示例2: 实现格斗游戏风格的投技

```csharp
protected override void RegisterAnimationStates()
{
    // 投技起手 - 高优先级，但起手阶段可被打断
    RegisterState("Throw_Start", 
        priority: AnimationPriority.Throw,
        cancelPolicy: AnimationCancelPolicy.CancellableInWindow,
        cancelWindows: new[] {
            new CancelWindow(0.0f, 0.2f)  // 前20%可被打断
        });

    // 投技抓取中 - 只能被更高优先级打断
    RegisterState("Throw_Hold", 
        priority: AnimationPriority.Throw,
        cancelPolicy: AnimationCancelPolicy.OnlyByHigherPriority);

    // 投技执行 - 完全不可取消
    RegisterState("Throw_Execute", 
        priority: AnimationPriority.Throw,
        cancelPolicy: AnimationCancelPolicy.NonCancellable);
}
```

### 示例3: 实现受击后的硬直和恢复

```csharp
public class HitStunController : MonoBehaviour
{
    private WarriorAnimationManager _animManager;
    private float _hitStunDuration = 0.5f;
    private float _hitStunTimer = 0f;

    void Update()
    {
        if (_hitStunTimer > 0)
        {
            _hitStunTimer -= Time.deltaTime;
            
            if (_hitStunTimer <= 0)
            {
                // 硬直结束，返回Idle
                _animManager.PlayIdle();
            }
        }
    }

    public void OnHit(bool isGrounded)
    {
        // 播放受击动画
        _animManager.PlaySmartHurt(isGrounded);
        
        // 开始硬直计时
        _hitStunTimer = _hitStunDuration;
    }
}
```

## 最佳实践 / Best Practices

### 1. 优先级设置建议

```
- Idle: 0 (最低)
- 移动动作: 10
- 跳跃: 20
- 普通攻击: 30
- 特殊技能: 40
- 投技: 50
- 受击: 60
- 击倒: 70
- 死亡: 100 (最高)
```

### 2. 取消窗口设置建议

- **连招系统**: 在攻击动画的40%-70%设置取消窗口
- **技能取消**: 在技能动画的80%以后允许取消
- **投技防御**: 在投技起手的前20%允许被打断

### 3. 性能优化

- 使用`CanPlayAnimation()`提前检查，避免无效的动画切换
- 合理设置优先级，减少不必要的优先级判断
- 取消窗口数量不宜过多（建议不超过3个）

## 常见问题 / FAQ

### Q1: 为什么我的攻击动画被其他动画打断了？

A: 检查优先级设置。如果受击动画优先级高于攻击，那么受击可以打断攻击。这通常是正确的行为。

### Q2: 如何实现"超级护甲"效果（攻击时不会被打断）？

```csharp
// 方法1: 提高攻击动画的优先级
RegisterState("SuperAttack", 
    priority: AnimationPriority.Skill,  // 高于普通受击
    cancelPolicy: AnimationCancelPolicy.NonCancellable);

// 方法2: 在特定时间段内临时提高优先级（需要自定义逻辑）
```

### Q3: 投技系统如何判断目标是否可被抓取？

A: 系统会检查：
1. 目标是否在范围内
2. 目标是否在角度内
3. 目标是否实现了`IThrowable`接口
4. `IThrowable.CanBeGrabbed()`返回true

### Q4: 如何实现连招计数？

A: 在取消窗口内成功播放下一个攻击时增加计数：

```csharp
if (_animManager.CanPlayAnimation("Attack"))
{
    _animManager.PlayAttack();
    _comboCount++;
}
```

## 文件清单 / File List

新增的文件：
- `AnimationPriority.cs` - 优先级和取消策略定义
- `ThrowAttackComponent.cs` - 投技系统组件
- `FightingGameAnimationExample.cs` - 完整使用示例
- 更新的 `AnimationStateManager.cs` - 支持取消机制
- 更新的 `CharacterAnimationManager.cs` - 支持新方法
- 更新的 `WarriorAnimationManager.cs` - 包含所有新动画状态

## 参考资料 / References

本系统的设计参考了以下格斗游戏的机制：
- Street Fighter系列（街头霸王）- 取消系统
- Guilty Gear系列 - 优先级系统
- King of Fighters系列（拳皇）- 投技系统

## 总结 / Summary

这个系统提供了：
✅ 完整的动画优先级管理
✅ 灵活的取消机制
✅ 专业的投技系统
✅ 智能的受击反应
✅ 易于扩展的架构

通过合理使用这些功能，可以实现复杂的格斗游戏动画逻辑，同时保持代码的清晰和可维护性。
