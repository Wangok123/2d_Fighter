# 2D Fighter 网络通信协议

## 协议概述

2D Fighter使用自定义的二进制协议，基于Protobuf进行序列化，通过KCP（基于UDP的可靠传输协议）进行网络传输。

## 协议栈架构

```
┌─────────────────────────────────────┐
│     Application Messages            │ 应用层消息
│  (LoginRequest, BattleStart, etc.)  │
└─────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────┐
│      Protobuf Serialization         │ 序列化层
│        (Binary Format)              │
└─────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────┐
│      Protocol Package Format        │ 协议包格式
│   [Header][ProtocolID][Body]        │
└─────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────┐
│         KCP Reliable UDP            │ 传输层
│     (Low Latency, Reliable)         │
└─────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────┐
│           UDP Socket                │ 网络层
└─────────────────────────────────────┘
```

## 协议包格式

### 基本格式

```
┌────────┬─────────────┬──────────────────┐
│ Length │ Protocol ID │   Message Body   │
│ 4 bytes│   4 bytes   │   Variable Size  │
└────────┴─────────────┴──────────────────┘
```

### 字段说明

1. **Length (4 bytes, uint32)**
   - 整个数据包的长度（包括Length字段本身）
   - 用于粘包和拆包处理
   - 网络字节序（Big Endian）

2. **Protocol ID (4 bytes, uint32)**
   - 协议类型标识
   - 用于消息路由和分发
   - 对应ProtocolID枚举

3. **Message Body (Variable Size)**
   - Protobuf序列化后的消息体
   - 长度 = Length - 8

## 协议定义文件

协议定义位于 `Protocal/Proto/` 目录：

```
Protocal/Proto/
├── common.proto      # 通用数据结构
├── login.proto       # 登录相关协议
├── match.proto       # 匹配相关协议
├── battle.proto      # 战斗相关协议
└── operation.proto   # 操作相关协议
```

## 协议详细定义

### 1. 通用协议（common.proto）

```protobuf
syntax = "proto3";
package GameProtocol;

// 用户数据传输对象
message UserDto {
    uint64 user_id = 1;    // 用户唯一ID
    string username = 2;   // 用户名
    int32 level = 6;       // 用户等级
    uint32 exp = 7;        // 用户经验值
}

// 英雄数据传输对象
message HeroDto {
    int32 hero_id = 1;     // 英雄ID
}

// 战斗英雄数据传输对象
message BattleHeroDto {
    string user_name = 1;  // 用户名
    int32 hero_id = 2;     // 英雄ID
}
```

### 2. 登录协议（login.proto）

```protobuf
syntax = "proto3";
package GameProtocol;

// 登录请求
message LoginRequest {
    string username = 1;   // 用户名
}

// 登录响应
message LoginResponse {
    uint64 user_id = 1;    // 用户ID
    string username = 2;   // 用户名
    int32 error_code = 3;  // 错误码（0表示成功）
    string message = 4;    // 错误信息
}
```

**协议ID**：
- LoginRequest: 4
- LoginResponse: 5

**流程**：
```
客户端 → 服务器: LoginRequest
服务器 → 客户端: LoginResponse
```

### 3. 匹配协议（match.proto）

```protobuf
syntax = "proto3";
package GameProtocol;

import "common.proto";

// 匹配请求
message MatchRequest {
    uint64 user_id = 1;    // 用户ID
}

// 匹配响应
message MatchResponse {
    int32 error_code = 1;      // 错误码
    repeated UserDto users = 2; // 匹配到的用户列表
}

// 确认通知
message ConfirmNotification {
    bool confirmed = 1;        // 是否确认
}

// 发送确认请求
message SendConfirmRequest {
    bool confirm = 1;          // 确认标志
}

// 选择通知
message SelectNotification {
    repeated BattleHeroDto heroes = 1; // 选择的英雄列表
}

// 发送选择请求
message SendSelectRequest {
    int32 hero_id = 1;         // 选择的英雄ID
}
```

**协议ID**：
- MatchRequest: 6
- MatchResponse: 7
- ConfirmNotification: 8
- SendConfirmRequest: 9
- SelectNotification: 10
- SendSelectRequest: 11

**匹配流程**：
```
1. 客户端 → 服务器: MatchRequest
2. 服务器 → 客户端: MatchResponse（匹配成功）
3. 客户端 → 服务器: SendConfirmRequest（确认匹配）
4. 服务器 → 所有客户端: ConfirmNotification（双方确认）
5. 客户端 → 服务器: SendSelectRequest（选择英雄）
6. 服务器 → 所有客户端: SelectNotification（英雄选择完成）
```

### 4. 战斗协议（battle.proto）

```protobuf
syntax = "proto3";
package GameProtocol;

// 战斗开始请求
message BattleStartRequest {
    // 空消息，仅作为信号
}

// 发送操作键请求
message SendOperationKeyRequest {
    int32 operation_key = 1;   // 操作键值
    uint32 frame_number = 2;   // 帧号
}

// 操作键通知（服务器广播）
message OperationKeyNotification {
    uint64 user_id = 1;        // 用户ID
    int32 operation_key = 2;   // 操作键值
    uint32 frame_number = 3;   // 帧号
}

// 加载进度通知
message LoadProgressNotification {
    uint64 user_id = 1;        // 用户ID
    float progress = 2;        // 加载进度（0-1）
}

// 发送加载进度请求
message SendLoadProgressRequest {
    float progress = 1;        // 加载进度
}

// 加载资源通知
message LoadResourceNotification {
    // 通知客户端开始加载资源
}

// 加载完成请求
message LoadingFinishRequest {
    // 客户端通知加载完成
}

// 加载完成通知
message LoadingFinishNotification {
    // 服务器通知所有客户端加载完成
}
```

**协议ID**：
- BattleStartRequest: 1
- SendOperationKeyRequest: 2
- OperationKeyNotification: 3
- LoadProgressNotification: 13
- SendLoadProgressRequest: 12
- LoadResourceNotification: 14
- LoadingFinishRequest: 15
- LoadingFinishNotification: 16

**战斗流程**：
```
1. 服务器 → 客户端: LoadResourceNotification（开始加载）
2. 客户端 → 服务器: SendLoadProgressRequest（上报进度）
3. 服务器 → 所有客户端: LoadProgressNotification（同步进度）
4. 客户端 → 服务器: LoadingFinishRequest（加载完成）
5. 服务器 → 所有客户端: LoadingFinishNotification（所有人加载完成）
6. 服务器 → 客户端: BattleStartRequest（战斗开始）
7. 客户端 → 服务器: SendOperationKeyRequest（发送操作）
8. 服务器 → 所有客户端: OperationKeyNotification（广播操作）
```

### 5. 操作协议（operation.proto）

```protobuf
syntax = "proto3";
package GameProtocol;

// 操作类型枚举
enum OperationType {
    NONE = 0;
    MOVE_LEFT = 1;     // 向左移动
    MOVE_RIGHT = 2;    // 向右移动
    JUMP = 3;          // 跳跃
    ATTACK = 4;        // 攻击
    SKILL_1 = 5;       // 技能1
    SKILL_2 = 6;       // 技能2
    SKILL_3 = 7;       // 技能3
    DEFEND = 8;        // 防御
}
```

## 协议ID映射表

| 协议ID | 协议名称 | 方向 | 说明 |
|-------|---------|------|------|
| 1 | BattleStartRequest | S→C | 战斗开始 |
| 2 | SendOperationKeyRequest | C→S | 发送操作 |
| 3 | OperationKeyNotification | S→C | 操作广播 |
| 4 | LoginRequest | C→S | 登录请求 |
| 5 | LoginResponse | S→C | 登录响应 |
| 6 | MatchRequest | C→S | 匹配请求 |
| 7 | MatchResponse | S→C | 匹配响应 |
| 8 | ConfirmNotification | S→C | 确认通知 |
| 9 | SendConfirmRequest | C→S | 发送确认 |
| 10 | SelectNotification | S→C | 选择通知 |
| 11 | SendSelectRequest | C→S | 发送选择 |
| 12 | SendLoadProgressRequest | C→S | 发送加载进度 |
| 13 | LoadProgressNotification | S→C | 加载进度通知 |
| 14 | LoadResourceNotification | S→C | 加载资源通知 |
| 15 | LoadingFinishRequest | C→S | 加载完成请求 |
| 16 | LoadingFinishNotification | S→C | 加载完成通知 |

**图例**：
- C→S：客户端发送给服务器
- S→C：服务器发送给客户端

## KCP配置参数

### 基础配置
```csharp
// KCP创建参数
conv: 会话ID（唯一标识）
user: 用户数据指针

// 性能参数
nodelay: 1        // 快速重传模式
interval: 10      // 更新间隔（ms）
resend: 2         // 快速重传倍数
nc: 1             // 关闭流控
```

### 窗口配置
```csharp
sndwnd: 128       // 发送窗口大小
rcvwnd: 128       // 接收窗口大小
```

### MTU配置
```csharp
mtu: 1400         // 最大传输单元
```

## 网络通信特点

### 1. 可靠性
- KCP保证消息可靠到达
- 自动重传机制
- 序列号保证顺序

### 2. 低延迟
- 快速重传模式
- 小的更新间隔
- 优化的拥塞控制

### 3. 高效性
- Protobuf二进制序列化
- 紧凑的包格式
- 减少网络开销

## 协议生成工具

### Protobuf编译
```bash
# Windows
protoc.exe --csharp_out=./Output *.proto

# Linux/Mac
protoc --csharp_out=./Output *.proto
```

### 自动生成脚本
**位置**：`Server/LatServer/Tools/ProtobufToCSharp.cs`

**功能**：
- 批量编译.proto文件
- 自动更新生成代码
- 同步到客户端和服务器

## 消息处理流程

### 客户端发送消息
```csharp
// 1. 创建消息对象
var request = new LoginRequest 
{ 
    Username = "player123" 
};

// 2. 序列化消息
byte[] body = ProtobufHelper.Serialize(request);

// 3. 添加协议头
byte[] packet = PacketBuilder.Build(ProtocolID.LoginRequest, body);

// 4. 通过KCP发送
session.Send(packet);
```

### 服务器接收消息
```csharp
// 1. 从KCP接收数据
byte[] packet = session.Receive();

// 2. 解析协议头
(uint length, uint protocolId, byte[] body) = PacketParser.Parse(packet);

// 3. 反序列化消息
var request = ProtobufHelper.Deserialize<LoginRequest>(body);

// 4. 查找并调用处理器
var handler = ProtocolManager.GetHandler(protocolId);
handler.Handle(session, request);
```

## 心跳机制

### 配置
```csharp
HeartbeatInterval: 5000ms    // 心跳间隔
Timeout: 30000ms             // 超时时间
```

### 流程
```
客户端定时发送心跳
   ↓
服务器收到心跳并响应
   ↓
更新最后活跃时间
   ↓
如果超时未收到心跳
   ↓
断开连接
```

## 断线重连

### 机制
1. 客户端检测到断线
2. 尝试重新连接
3. 发送重连请求（带用户ID）
4. 服务器验证并恢复状态
5. 同步当前游戏状态

### 状态保持
- 服务器保留断线玩家状态（60秒）
- 重连后恢复游戏进度
- 如果超时则判定退出

## 错误处理

### 错误码定义
```csharp
public enum ErrorCodeID
{
    Success = 0,
    
    // 网络错误 1000-1999
    NetworkError = 1000,
    ConnectionFailed = 1001,
    Timeout = 1002,
    
    // 登录错误 2000-2999
    LoginFailed = 2000,
    InvalidUsername = 2001,
    
    // 匹配错误 3000-3999
    MatchFailed = 3000,
    MatchTimeout = 3001,
    
    // 战斗错误 4000-4999
    BattleError = 4000,
    InvalidOperation = 4001,
}
```

### 错误处理流程
```
发生错误
   ↓
记录错误日志
   ↓
构造错误响应
   ↓
发送给客户端
   ↓
客户端显示错误信息
```

## 安全性考虑

### 1. 数据验证
- 验证消息长度
- 验证协议ID有效性
- 验证消息内容合法性

### 2. 防作弊
- 服务器权威验证
- 操作频率限制
- 异常行为检测

### 3. 加密（可选）
- 消息加密
- 签名验证
- 防重放攻击

## 性能优化

### 1. 消息合并
- 多个小消息合并发送
- 减少网络往返

### 2. 压缩
- 大消息使用压缩
- 降低带宽占用

### 3. 对象池
- 复用消息对象
- 减少GC压力

## 调试工具

### 1. 抓包工具
- Wireshark抓取UDP包
- 查看网络流量

### 2. 日志系统
- 记录所有消息收发
- 便于问题排查

### 3. 协议测试工具
- 模拟客户端
- 测试协议正确性

## 相关文档

- [项目总览](01-项目总览.md)
- [技术栈详解](02-技术栈.md)
- [客户端架构](03-客户端架构.md)
- [服务端架构](04-服务端架构.md)
- [API文档](06-API文档.md)
